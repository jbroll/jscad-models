import { geometries as T, transforms as t, colors as c, hulls as l, expansions as g, booleans as o, measurements as u, extrusions as x, primitives as s } from "@jscad/modeling";
const { geom3: Z } = T;
class i {
  constructor(r) {
    this.type = "geom3", Object.assign(this, r ?? Z.create());
  }
  // biome-ignore lint/suspicious/noExplicitAny: Required for polymorphic wrapper
  _wrap(r) {
    return new this.constructor(r);
  }
  append(r) {
    return p.create(this, r);
  }
  translate(r) {
    return this._wrap(t.translate(r, this));
  }
  translateX(r) {
    return this._wrap(t.translateX(r, this));
  }
  translateY(r) {
    return this._wrap(t.translateY(r, this));
  }
  translateZ(r) {
    return this._wrap(t.translateZ(r, this));
  }
  rotate(r) {
    return this._wrap(t.rotate(r, this));
  }
  rotateX(r) {
    return this._wrap(t.rotateX(r, this));
  }
  rotateY(r) {
    return this._wrap(t.rotateY(r, this));
  }
  rotateZ(r) {
    return this._wrap(t.rotateZ(r, this));
  }
  scale(r) {
    return this._wrap(t.scale(r, this));
  }
  scaleX(r) {
    return this._wrap(t.scaleX(r, this));
  }
  scaleY(r) {
    return this._wrap(t.scaleY(r, this));
  }
  scaleZ(r) {
    return this._wrap(t.scaleZ(r, this));
  }
  mirror(r) {
    return this._wrap(t.mirror(r, this));
  }
  mirrorX() {
    return this._wrap(t.mirrorX(this));
  }
  mirrorY() {
    return this._wrap(t.mirrorY(this));
  }
  mirrorZ() {
    return this._wrap(t.mirrorZ(this));
  }
  center(r) {
    return this._wrap(t.center(r, this));
  }
  centerX() {
    return this._wrap(t.centerX(this));
  }
  centerY() {
    return this._wrap(t.centerY(this));
  }
  centerZ() {
    return this._wrap(t.centerZ(this));
  }
  transform(r) {
    return this._wrap(t.transform(r, this));
  }
  colorize(r) {
    return this._wrap(c.colorize(r, this));
  }
  hull() {
    return this._wrap(l.hull(this));
  }
  hullChain() {
    return this._wrap(l.hullChain(this));
  }
  expand(r) {
    return this._wrap(g.expand(r, this));
  }
  union(...r) {
    return this._wrap(o.union([this, ...r]));
  }
  subtract(...r) {
    return this._wrap(o.subtract([this, ...r]));
  }
  intersect(...r) {
    return this._wrap(o.intersect([this, ...r]));
  }
  measureBoundingBox() {
    return u.measureBoundingBox(this);
  }
  measureBoundingSphere() {
    return u.measureBoundingSphere(this);
  }
  measureCenter() {
    return u.measureCenter(this);
  }
  measureDimensions() {
    return u.measureDimensions(this);
  }
  measureVolume() {
    return u.measureVolume(this);
  }
  toPolygons() {
    return Z.toPolygons(this);
  }
  validate() {
    Z.validate(this);
  }
  toString() {
    return Z.toString(this);
  }
}
class n extends Array {
  constructor(...r) {
    super(...r), Object.setPrototypeOf(this, n.prototype);
  }
  translate(r) {
    return new n(...t.translate(r, this));
  }
  translateX(r) {
    return new n(...t.translateX(r, this));
  }
  translateY(r) {
    return new n(...t.translateY(r, this));
  }
  translateZ(r) {
    return new n(...t.translateZ(r, this));
  }
  rotate(r) {
    return new n(...t.rotate(r, this));
  }
  rotateX(r) {
    return new n(...t.rotateX(r, this));
  }
  rotateY(r) {
    return new n(...t.rotateY(r, this));
  }
  rotateZ(r) {
    return new n(...t.rotateZ(r, this));
  }
  scale(r) {
    return new n(...t.scale(r, this));
  }
  scaleX(r) {
    return new n(...t.scaleX(r, this));
  }
  scaleY(r) {
    return new n(...t.scaleY(r, this));
  }
  scaleZ(r) {
    return new n(...t.scaleZ(r, this));
  }
  mirror(r) {
    return new n(...t.mirror(r, this));
  }
  mirrorX() {
    return new n(...t.mirrorX(this));
  }
  mirrorY() {
    return new n(...t.mirrorY(this));
  }
  mirrorZ() {
    return new n(...t.mirrorZ(this));
  }
  center(r) {
    return new n(...t.center(r, this));
  }
  centerX() {
    return new n(...t.centerX(this));
  }
  centerY() {
    return new n(...t.centerY(this));
  }
  centerZ() {
    return new n(...t.centerZ(this));
  }
  transform(r) {
    return new n(...t.transform(r, this));
  }
  colorize(r) {
    return new n(...c.colorize(r, this));
  }
  toString() {
    return `FluentGeometryArray(${this.length})[${this.map((r) => r.toString()).join(", ")}]`;
  }
}
class p extends n {
  constructor(...r) {
    super(...r), Object.setPrototypeOf(this, p.prototype);
  }
  static create(...r) {
    return new p(...r);
  }
  append(r) {
    return super.push(r), this;
  }
  hull() {
    return new i(l.hull(this));
  }
  hullChain() {
    return new i(l.hullChain(this));
  }
}
class R extends n {
  constructor(...r) {
    super(...r), Object.setPrototypeOf(this, R.prototype);
  }
  static create(...r) {
    return new R(...r);
  }
  append(r) {
    return super.push(r), this;
  }
  extrudeLinear(r) {
    return p.create(...this.map((a) => x.extrudeLinear(r, a)));
  }
  extrudeRotate(r) {
    return p.create(...this.map((a) => x.extrudeRotate(r, a)));
  }
  hull() {
    return new h(l.hull(this));
  }
  hullChain() {
    return new h(l.hullChain(this));
  }
}
const { geom2: d } = T;
class h {
  constructor(r) {
    this.type = "geom2", Object.assign(this, r ?? d.create());
  }
  // biome-ignore lint/suspicious/noExplicitAny: Required for polymorphic wrapper
  _wrap(r) {
    return new this.constructor(r);
  }
  append(r) {
    return R.create(this, r);
  }
  translate(r) {
    return this._wrap(t.translate(r, this));
  }
  translateX(r) {
    return this._wrap(t.translateX(r, this));
  }
  translateY(r) {
    return this._wrap(t.translateY(r, this));
  }
  translateZ(r) {
    return this._wrap(t.translateZ(r, this));
  }
  rotate(r) {
    return this._wrap(t.rotate(r, this));
  }
  rotateX(r) {
    return this._wrap(t.rotateX(r, this));
  }
  rotateY(r) {
    return this._wrap(t.rotateY(r, this));
  }
  rotateZ(r) {
    return this._wrap(t.rotateZ(r, this));
  }
  scale(r) {
    return this._wrap(t.scale(r, this));
  }
  scaleX(r) {
    return this._wrap(t.scaleX(r, this));
  }
  scaleY(r) {
    return this._wrap(t.scaleY(r, this));
  }
  scaleZ(r) {
    return this._wrap(t.scaleZ(r, this));
  }
  mirror(r) {
    return this._wrap(t.mirror(r, this));
  }
  mirrorX() {
    return this._wrap(t.mirrorX(this));
  }
  mirrorY() {
    return this._wrap(t.mirrorY(this));
  }
  mirrorZ() {
    return this._wrap(t.mirrorZ(this));
  }
  center(r) {
    return this._wrap(t.center(r, this));
  }
  centerX() {
    return this._wrap(t.centerX(this));
  }
  centerY() {
    return this._wrap(t.centerY(this));
  }
  centerZ() {
    return this._wrap(t.centerZ(this));
  }
  transform(r) {
    return this._wrap(t.transform(r, this));
  }
  colorize(r) {
    return this._wrap(c.colorize(r, this));
  }
  expand(r) {
    return this._wrap(g.expand(r, this));
  }
  offset(r) {
    return this._wrap(g.offset(r, this));
  }
  union(...r) {
    return this._wrap(o.union([this, ...r]));
  }
  subtract(...r) {
    return this._wrap(o.subtract([this, ...r]));
  }
  intersect(...r) {
    return this._wrap(o.intersect([this, ...r]));
  }
  hull() {
    return this._wrap(l.hull(this));
  }
  hullChain() {
    return this._wrap(l.hullChain(this));
  }
  extrudeLinear(r) {
    const a = x.extrudeLinear(r, this);
    return new i(a);
  }
  extrudeRotate(r) {
    const a = x.extrudeRotate(r, this);
    return new i(a);
  }
  measureBoundingBox() {
    return u.measureBoundingBox(this);
  }
  measureBoundingSphere() {
    return u.measureBoundingSphere(this);
  }
  measureCenter() {
    return u.measureCenter(this);
  }
  measureDimensions() {
    return u.measureDimensions(this);
  }
  measureArea() {
    return u.measureArea(this);
  }
  toPoints() {
    return d.toPoints(this);
  }
  toOutlines() {
    return d.toOutlines(this);
  }
  validate() {
    d.validate(this);
  }
  toString() {
    return d.toString(this);
  }
}
class C extends n {
  constructor(...r) {
    super(...r), Object.setPrototypeOf(this, C.prototype);
  }
  static create(...r) {
    return new C(...r);
  }
  append(r) {
    return super.push(r), this;
  }
  hull() {
    return new S(l.hull(this));
  }
  hullChain() {
    return new S(l.hullChain(this));
  }
}
const { path2: b } = T;
class S {
  constructor(r) {
    this.type = "path2", Object.assign(this, r ?? b.create());
  }
  // biome-ignore lint/suspicious/noExplicitAny: Required for polymorphic wrapper
  _wrap(r) {
    return new this.constructor(r);
  }
  append(r) {
    return C.create(this, r);
  }
  translate(r) {
    return this._wrap(t.translate(r, this));
  }
  translateX(r) {
    return this._wrap(t.translateX(r, this));
  }
  translateY(r) {
    return this._wrap(t.translateY(r, this));
  }
  translateZ(r) {
    return this._wrap(t.translateZ(r, this));
  }
  rotate(r) {
    return this._wrap(t.rotate(r, this));
  }
  rotateX(r) {
    return this._wrap(t.rotateX(r, this));
  }
  rotateY(r) {
    return this._wrap(t.rotateY(r, this));
  }
  rotateZ(r) {
    return this._wrap(t.rotateZ(r, this));
  }
  scale(r) {
    return this._wrap(t.scale(r, this));
  }
  scaleX(r) {
    return this._wrap(t.scaleX(r, this));
  }
  scaleY(r) {
    return this._wrap(t.scaleY(r, this));
  }
  scaleZ(r) {
    return this._wrap(t.scaleZ(r, this));
  }
  mirror(r) {
    return this._wrap(t.mirror(r, this));
  }
  mirrorX() {
    return this._wrap(t.mirrorX(this));
  }
  mirrorY() {
    return this._wrap(t.mirrorY(this));
  }
  mirrorZ() {
    return this._wrap(t.mirrorZ(this));
  }
  center(r) {
    return this._wrap(t.center(r, this));
  }
  centerX() {
    return this._wrap(t.centerX(this));
  }
  centerY() {
    return this._wrap(t.centerY(this));
  }
  centerZ() {
    return this._wrap(t.centerZ(this));
  }
  transform(r) {
    return this._wrap(t.transform(r, this));
  }
  colorize(r) {
    return this._wrap(c.colorize(r, this));
  }
  expand(r) {
    return this._wrap(g.expand(r, this));
  }
  offset(r) {
    return this._wrap(g.offset(r, this));
  }
  hull() {
    return this._wrap(l.hull(this));
  }
  hullChain() {
    return this._wrap(l.hullChain(this));
  }
  measureBoundingBox() {
    return u.measureBoundingBox(this);
  }
  measureBoundingSphere() {
    return u.measureBoundingSphere(this);
  }
  measureCenter() {
    return u.measureCenter(this);
  }
  measureDimensions() {
    return u.measureDimensions(this);
  }
  measureArea() {
    return u.measureArea(this);
  }
  toPoints() {
    return b.toPoints(this);
  }
  validate() {
    b.validate(this);
  }
  toString() {
    return b.toString(this);
  }
}
function j(...e) {
  if (e.length === 0)
    throw new Error("union requires at least one geometry");
  return (Array.isArray(e[0]) ? e[0][0] : e[0]) instanceof h ? new h(o.union(e)) : new i(o.union(e));
}
function z(...e) {
  if (e.length === 0)
    throw new Error("subtract requires at least one geometry");
  return (Array.isArray(e[0]) ? e[0][0] : e[0]) instanceof h ? new h(o.subtract(e)) : new i(o.subtract(e));
}
function D(...e) {
  if (e.length === 0)
    throw new Error("intersect requires at least one geometry");
  return (Array.isArray(e[0]) ? e[0][0] : e[0]) instanceof h ? new h(o.intersect(e)) : new i(o.intersect(e));
}
const H = Math.PI * 2;
function m(e, r = 1) {
  if (e === void 0)
    return [
      [r, r],
      [r, r]
    ];
  if (typeof e == "number")
    return [
      [e, e],
      [e, e]
    ];
  const [a, w] = e;
  return [Array.isArray(a) ? a : [a, a], Array.isArray(w) ? w : [w, w]];
}
function q(e) {
  const r = {
    height: 1,
    segments: 32,
    center: [0, 0, 0],
    ...e
  }, [a, w] = r.angle ?? [0, H];
  let B = e.inner;
  if (e.wall !== void 0) {
    const [_, f] = m(e.outer ?? e.radius), [X, Y] = m(e.wall);
    B = [
      [_[0] - X[0], _[1] - X[1]],
      [f[0] - Y[0], f[1] - Y[1]]
    ];
  }
  if (B !== void 0) {
    const [_, f] = m(e.outer ?? e.radius), [X, Y] = m(B), E = s.cylinderElliptic({
      height: r.height,
      segments: r.segments,
      center: r.center,
      startRadius: _,
      endRadius: f,
      startAngle: a,
      endAngle: w
    }), P = s.cylinderElliptic({
      height: r.height,
      segments: r.segments,
      center: r.center,
      startRadius: X,
      endRadius: Y,
      startAngle: a,
      endAngle: w
    });
    return new i(o.subtract(E, P));
  }
  const [v, O] = m(e.radius);
  return new i(
    s.cylinderElliptic({
      height: r.height,
      segments: r.segments,
      center: r.center,
      startRadius: v,
      endRadius: O,
      startAngle: a,
      endAngle: w
    })
  );
}
const N = {
  // Path2 Primitives
  arc(e) {
    return new S(s.arc(e));
  },
  line(e) {
    return new S(s.line(e));
  },
  // 2D Primitives
  rectangle(e) {
    return new h(s.rectangle(e));
  },
  roundedRectangle(e) {
    return new h(s.roundedRectangle(e));
  },
  circle(e) {
    return new h(s.circle(e));
  },
  ellipse(e) {
    return new h(s.ellipse(e));
  },
  polygon(e) {
    return new h(s.polygon({ points: e }));
  },
  square(e) {
    return new h(s.square(e));
  },
  star(e) {
    return new h(s.star(e));
  },
  triangle(e) {
    return new h(s.triangle(e));
  },
  // 3D Primitives
  cube(e) {
    return new i(s.cube(e));
  },
  cuboid(e) {
    return new i(s.cuboid(e));
  },
  sphere(e) {
    return new i(s.sphere(e));
  },
  /**
   * Creates a flexible cylinder - solid, hollow, or with wall thickness.
   * Supports uniform, tapered, elliptical cross-sections and partial arcs.
   *
   * @example
   * // Simple solid cylinder (backwards compatible)
   * jf.cylinder({ radius: 5, height: 10 })
   *
   * // Tapered cylinder
   * jf.cylinder({ radius: [5, 3], height: 10 })
   *
   * // Elliptical cylinder
   * jf.cylinder({ radius: [[5, 3], [5, 3]], height: 10 })
   *
   * // Hollow cylinder
   * jf.cylinder({ outer: 6, inner: 4, height: 10 })
   *
   * // Pipe with wall thickness
   * jf.cylinder({ outer: 6, wall: 1, height: 10 })
   *
   * // Partial arc (quarter cylinder)
   * jf.cylinder({ radius: 5, height: 10, angle: [0, Math.PI / 2] })
   */
  cylinder(e) {
    return q(e);
  },
  cylinderElliptic(e) {
    return new i(s.cylinderElliptic(e));
  },
  torus(e) {
    return new i(s.torus(e));
  },
  ellipsoid(e) {
    return new i(s.ellipsoid(e));
  },
  geodesicSphere(e) {
    return new i(s.geodesicSphere(e));
  },
  roundedCuboid(e) {
    return new i(s.roundedCuboid(e));
  },
  roundedCylinder(e) {
    return new i(s.roundedCylinder(e));
  },
  polyhedron({
    points: e,
    faces: r
  }) {
    return new i(s.polyhedron({ points: e, faces: r }));
  },
  // Boolean operations (top-level) - reference overloaded functions
  union: j,
  subtract: z,
  intersect: D,
  /**
   * Color utilities for converting between color formats.
   * All color values are normalized to 0-1 range for use with colorize().
   */
  colors: {
    /**
     * Convert hex color notation to RGB or RGBA.
     * @param hex - Hex color string (e.g., '#FF0000', '#F00', '#FF000080')
     * @returns RGB or RGBA tuple with values 0-1
     * @example
     * jscadFluent.colors.hexToRgb('#FF0000')  // [1, 0, 0]
     * jscadFluent.colors.hexToRgb('#FF000080')  // [1, 0, 0, 0.5]
     */
    hexToRgb: c.hexToRgb,
    /**
     * Convert CSS color name to RGB.
     * @param name - CSS color name (e.g., 'red', 'lightblue', 'cornflowerblue')
     * @returns RGB tuple with values 0-1
     * @example
     * jscadFluent.colors.colorNameToRgb('red')  // [1, 0, 0]
     * jscadFluent.colors.colorNameToRgb('lightblue')  // [0.68, 0.85, 0.9]
     */
    colorNameToRgb: c.colorNameToRgb,
    /**
     * Convert HSL to RGB. All values use 0-1 range.
     * @param hsl - HSL or HSLA tuple (all values 0-1)
     * @returns RGB or RGBA tuple with values 0-1
     * @example
     * jscadFluent.colors.hslToRgb([0, 1, 0.5])  // Red: [1, 0, 0]
     * jscadFluent.colors.hslToRgb([0.33, 1, 0.5])  // Green
     */
    hslToRgb: c.hslToRgb,
    /**
     * Convert HSV to RGB. All values use 0-1 range.
     * @param hsv - HSV or HSVA tuple (all values 0-1)
     * @returns RGB or RGBA tuple with values 0-1
     * @example
     * jscadFluent.colors.hsvToRgb([0, 1, 1])  // Red: [1, 0, 0]
     * jscadFluent.colors.hsvToRgb([0.33, 1, 1])  // Green
     */
    hsvToRgb: c.hsvToRgb,
    /**
     * Convert RGB to hex notation.
     * @param rgb - RGB or RGBA tuple with values 0-1
     * @returns Hex color string
     * @example
     * jscadFluent.colors.rgbToHex([1, 0, 0])  // '#FF0000'
     */
    rgbToHex: c.rgbToHex,
    /**
     * Convert RGB to HSL.
     * @param rgb - RGB or RGBA tuple with values 0-1
     * @returns HSL or HSLA tuple
     */
    rgbToHsl: c.rgbToHsl,
    /**
     * Convert RGB to HSV.
     * @param rgb - RGB or RGBA tuple with values 0-1
     * @returns HSV or HSVA tuple
     */
    rgbToHsv: c.rgbToHsv,
    /**
     * CSS color constants (150+ named colors).
     * All values are RGB tuples with values 0-1.
     * @example
     * jscadFluent.colors.css.red  // [1, 0, 0]
     * jscadFluent.colors.css.lightblue  // [0.68, 0.85, 0.9]
     */
    css: c.cssColors
  }
};
export {
  N as default
};
